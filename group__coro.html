<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bio: Coroutine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">bio
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__coro.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Coroutine</div></div>
</div><!--header-->
<div class="contents">

<p>Cooperative scheduling.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__signal" id="r_group__signal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__signal.html">Signal</a></td></tr>
<tr class="memdesc:group__signal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waiting for an event to complete. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__monitor" id="r_group__monitor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monitor.html">Monitor</a></td></tr>
<tr class="memdesc:group__monitor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor a coroutine for termination. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio__coro__t.html">bio_coro_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to a coroutine.  <a href="structbio__coro__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio__monitor__t.html">bio_monitor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to a monitor.  <a href="structbio__monitor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbio__cls__t.html">bio_cls_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coroutine-local storage (CLS) specification.  <a href="structbio__cls__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga329934e366d0c7a3de9becc8bc3c67c5" id="r_ga329934e366d0c7a3de9becc8bc3c67c5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga329934e366d0c7a3de9becc8bc3c67c5">bio_entrypoint_t</a>) (void *userdata)</td></tr>
<tr class="memdesc:ga329934e366d0c7a3de9becc8bc3c67c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entrypoint for a coroutine.  <br /></td></tr>
<tr class="separator:ga329934e366d0c7a3de9becc8bc3c67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga94f6989d9bb01e8af4b14575643ae55c" id="r_ga94f6989d9bb01e8af4b14575643ae55c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga94f6989d9bb01e8af4b14575643ae55c">bio_coro_state_t</a> { <a class="el" href="group__coro.html#gga94f6989d9bb01e8af4b14575643ae55ca4ff0fc51ec5e3fe249b3b82a671843ed">BIO_CORO_READY</a>
, <a class="el" href="group__coro.html#gga94f6989d9bb01e8af4b14575643ae55ca08ff5cd429f3e0e9839f827825f6b60f">BIO_CORO_RUNNING</a>
, <a class="el" href="group__coro.html#gga94f6989d9bb01e8af4b14575643ae55ca10f87df124d884f7d34dfed054def8df">BIO_CORO_WAITING</a>
, <a class="el" href="group__coro.html#gga94f6989d9bb01e8af4b14575643ae55ca07f18b2b5552c168a8cba22a9cd46214">BIO_CORO_DEAD</a>
 }</td></tr>
<tr class="memdesc:ga94f6989d9bb01e8af4b14575643ae55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of a coroutine.  <a href="group__coro.html#ga94f6989d9bb01e8af4b14575643ae55c">More...</a><br /></td></tr>
<tr class="separator:ga94f6989d9bb01e8af4b14575643ae55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae947d3e23e02081e761fde6022c9805a" id="r_gae947d3e23e02081e761fde6022c9805a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbio__coro__t.html">bio_coro_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#gae947d3e23e02081e761fde6022c9805a">bio_spawn</a> (<a class="el" href="group__coro.html#ga329934e366d0c7a3de9becc8bc3c67c5">bio_entrypoint_t</a> entrypoint, void *userdata)</td></tr>
<tr class="memdesc:gae947d3e23e02081e761fde6022c9805a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a new coroutine.  <br /></td></tr>
<tr class="separator:gae947d3e23e02081e761fde6022c9805a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed9911140a74eb570e214fcc0ecc44e7" id="r_gaed9911140a74eb570e214fcc0ecc44e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__coro.html#ga94f6989d9bb01e8af4b14575643ae55c">bio_coro_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#gaed9911140a74eb570e214fcc0ecc44e7">bio_coro_state</a> (<a class="el" href="structbio__coro__t.html">bio_coro_t</a> coro)</td></tr>
<tr class="memdesc:gaed9911140a74eb570e214fcc0ecc44e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the state of a coroutine.  <br /></td></tr>
<tr class="separator:gaed9911140a74eb570e214fcc0ecc44e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9b296396e30ecc1c8bdee5fcdd3c90" id="r_ga9c9b296396e30ecc1c8bdee5fcdd3c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbio__coro__t.html">bio_coro_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga9c9b296396e30ecc1c8bdee5fcdd3c90">bio_current_coro</a> (void)</td></tr>
<tr class="memdesc:ga9c9b296396e30ecc1c8bdee5fcdd3c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the handle of the currently running coroutine.  <br /></td></tr>
<tr class="separator:ga9c9b296396e30ecc1c8bdee5fcdd3c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f37450bb3b8f1293eb53858af4de8a8" id="r_ga6f37450bb3b8f1293eb53858af4de8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga6f37450bb3b8f1293eb53858af4de8a8">bio_yield</a> (void)</td></tr>
<tr class="memdesc:ga6f37450bb3b8f1293eb53858af4de8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let a different coroutine run.  <br /></td></tr>
<tr class="separator:ga6f37450bb3b8f1293eb53858af4de8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3ca02984a2e1c83528133cb2e5033a" id="r_ga8b3ca02984a2e1c83528133cb2e5033a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga8b3ca02984a2e1c83528133cb2e5033a">bio_set_coro_data</a> (void *data, const <a class="el" href="structbio__tag__t.html">bio_tag_t</a> *tag)</td></tr>
<tr class="memdesc:ga8b3ca02984a2e1c83528133cb2e5033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate the calling coroutine with arbitrary data and a tag.  <br /></td></tr>
<tr class="separator:ga8b3ca02984a2e1c83528133cb2e5033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83531922e7e9259e2d0a9bba664bd6da" id="r_ga83531922e7e9259e2d0a9bba664bd6da"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga83531922e7e9259e2d0a9bba664bd6da">bio_get_coro_data</a> (<a class="el" href="structbio__coro__t.html">bio_coro_t</a> coro, const <a class="el" href="structbio__tag__t.html">bio_tag_t</a> *tag)</td></tr>
<tr class="memdesc:ga83531922e7e9259e2d0a9bba664bd6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the data associated with a coroutine.  <br /></td></tr>
<tr class="separator:ga83531922e7e9259e2d0a9bba664bd6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a7285e28a3af61e336163c931d0adb" id="r_ga97a7285e28a3af61e336163c931d0adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga97a7285e28a3af61e336163c931d0adb">bio_set_coro_name</a> (const char *name)</td></tr>
<tr class="memdesc:ga97a7285e28a3af61e336163c931d0adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a human-readable name to the calling coroutine.  <br /></td></tr>
<tr class="separator:ga97a7285e28a3af61e336163c931d0adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d004977f3fb35d5e5088b951db80645" id="r_ga5d004977f3fb35d5e5088b951db80645"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga5d004977f3fb35d5e5088b951db80645">bio_get_coro_name</a> (<a class="el" href="structbio__coro__t.html">bio_coro_t</a> coro)</td></tr>
<tr class="memdesc:ga5d004977f3fb35d5e5088b951db80645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human-readable name for the coroutine if it has one.  <br /></td></tr>
<tr class="separator:ga5d004977f3fb35d5e5088b951db80645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bd8daa462c84b184e870816a6f89a1" id="r_ga45bd8daa462c84b184e870816a6f89a1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coro.html#ga45bd8daa462c84b184e870816a6f89a1">bio_get_cls</a> (const <a class="el" href="structbio__cls__t.html">bio_cls_t</a> *cls)</td></tr>
<tr class="memdesc:ga45bd8daa462c84b184e870816a6f89a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a coroutine-local storage (CLS) object.  <br /></td></tr>
<tr class="separator:ga45bd8daa462c84b184e870816a6f89a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Cooperative scheduling. </p>
<p>At the heart of bio is a cooperative scheduling system. Coroutines are generally cheaper to spawn and context switch compared to threads.</p>
<p>Instead of using callbacks, all I/O calls in bio will block the calling coroutine. A different coroutine will be scheduled to run and the original coroutine will only resume once the original call return.</p>
<p>Coroutines can interact with one another through:</p>
<ul>
<li><a class="el" href="group__signal.html">Signal</a></li>
<li><a class="el" href="group__monitor.html">Monitor</a></li>
<li><a class="el" href="group__mailbox.html">Mailbox</a></li>
<li><a class="el" href="group__coro.html#ga8b3ca02984a2e1c83528133cb2e5033a">Associated data</a> </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga329934e366d0c7a3de9becc8bc3c67c5" name="ga329934e366d0c7a3de9becc8bc3c67c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329934e366d0c7a3de9becc8bc3c67c5">&#9670;&#160;</a></span>bio_entrypoint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* bio_entrypoint_t) (void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entrypoint for a coroutine. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coro.html#gae947d3e23e02081e761fde6022c9805a" title="Spawn a new coroutine.">bio_spawn</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga94f6989d9bb01e8af4b14575643ae55c" name="ga94f6989d9bb01e8af4b14575643ae55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f6989d9bb01e8af4b14575643ae55c">&#9670;&#160;</a></span>bio_coro_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__coro.html#ga94f6989d9bb01e8af4b14575643ae55c">bio_coro_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of a coroutine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga94f6989d9bb01e8af4b14575643ae55ca4ff0fc51ec5e3fe249b3b82a671843ed" name="gga94f6989d9bb01e8af4b14575643ae55ca4ff0fc51ec5e3fe249b3b82a671843ed"></a>BIO_CORO_READY&#160;</td><td class="fielddoc"><p>The coroutine is ready to run but not running yet. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94f6989d9bb01e8af4b14575643ae55ca08ff5cd429f3e0e9839f827825f6b60f" name="gga94f6989d9bb01e8af4b14575643ae55ca08ff5cd429f3e0e9839f827825f6b60f"></a>BIO_CORO_RUNNING&#160;</td><td class="fielddoc"><p>The coroutine is the currently running coroutine that called <a class="el" href="group__coro.html#gaed9911140a74eb570e214fcc0ecc44e7">bio_coro_state</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94f6989d9bb01e8af4b14575643ae55ca10f87df124d884f7d34dfed054def8df" name="gga94f6989d9bb01e8af4b14575643ae55ca10f87df124d884f7d34dfed054def8df"></a>BIO_CORO_WAITING&#160;</td><td class="fielddoc"><p>The coroutine is waiting for a <a class="el" href="group__signal.html#ga38cd6e3e58864cbf19fc86ff352bb44a">signal</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga94f6989d9bb01e8af4b14575643ae55ca07f18b2b5552c168a8cba22a9cd46214" name="gga94f6989d9bb01e8af4b14575643ae55ca07f18b2b5552c168a8cba22a9cd46214"></a>BIO_CORO_DEAD&#160;</td><td class="fielddoc"><p>The coroutine has terminated. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaed9911140a74eb570e214fcc0ecc44e7" name="gaed9911140a74eb570e214fcc0ecc44e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed9911140a74eb570e214fcc0ecc44e7">&#9670;&#160;</a></span>bio_coro_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__coro.html#ga94f6989d9bb01e8af4b14575643ae55c">bio_coro_state_t</a> bio_coro_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbio__coro__t.html">bio_coro_t</a>&#160;</td>
          <td class="paramname"><em>coro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the state of a coroutine. </p>

</div>
</div>
<a id="ga9c9b296396e30ecc1c8bdee5fcdd3c90" name="ga9c9b296396e30ecc1c8bdee5fcdd3c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9b296396e30ecc1c8bdee5fcdd3c90">&#9670;&#160;</a></span>bio_current_coro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbio__coro__t.html">bio_coro_t</a> bio_current_coro </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the handle of the currently running coroutine. </p>

</div>
</div>
<a id="ga45bd8daa462c84b184e870816a6f89a1" name="ga45bd8daa462c84b184e870816a6f89a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45bd8daa462c84b184e870816a6f89a1">&#9670;&#160;</a></span>bio_get_cls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * bio_get_cls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbio__cls__t.html">bio_cls_t</a> *&#160;</td>
          <td class="paramname"><em>cls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a coroutine-local storage (CLS) object. </p>
<p>This is used when something needs to be (lazily) created once in each coroutine. The CLS spec should be a global variable in a .c/.cpp file and passed as a pointer:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keywordtype">int</span> foo;</div>
<div class="line">} my_cls_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">init_my_cls(<span class="keywordtype">void</span>* ptr) {</div>
<div class="line">    my_cls_t* cls = ptr;</div>
<div class="line">    *cls = (my_cls_t){ .foo = 42 };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="structbio__cls__t.html">bio_cls_t</a> MY_CLS = {</div>
<div class="line">    .<a class="code hl_variable" href="structbio__cls__t.html#a8c3a76782a12d10b720976e42b2d6dd8">size</a> = <span class="keyword">sizeof</span>(my_cls_t),</div>
<div class="line">    .init = &amp;init_my_cls,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> entrypoint(<span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    my_cls_t* cls = <a class="code hl_function" href="group__coro.html#ga45bd8daa462c84b184e870816a6f89a1">bio_get_cls</a>(&amp;MY_CLS);</div>
<div class="line">    assert(cls-&gt;foo == 42);  <span class="comment">// Initialized</span></div>
<div class="line"> </div>
<div class="line">    my_cls_t* cls2 = <a class="code hl_function" href="group__coro.html#ga45bd8daa462c84b184e870816a6f89a1">bio_get_cls</a>(&amp;MY_CLS);</div>
<div class="line">    assert(cls == cls2);  <span class="comment">// The same object</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__coro_html_ga45bd8daa462c84b184e870816a6f89a1"><div class="ttname"><a href="group__coro.html#ga45bd8daa462c84b184e870816a6f89a1">bio_get_cls</a></div><div class="ttdeci">void * bio_get_cls(const bio_cls_t *cls)</div><div class="ttdoc">Get a coroutine-local storage (CLS) object.</div></div>
<div class="ttc" id="astructbio__cls__t_html"><div class="ttname"><a href="structbio__cls__t.html">bio_cls_t</a></div><div class="ttdoc">Coroutine-local storage (CLS) specification.</div><div class="ttdef"><b>Definition</b> bio.h:294</div></div>
<div class="ttc" id="astructbio__cls__t_html_a8c3a76782a12d10b720976e42b2d6dd8"><div class="ttname"><a href="structbio__cls__t.html#a8c3a76782a12d10b720976e42b2d6dd8">bio_cls_t::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">Size of the data.</div><div class="ttdef"><b>Definition</b> bio.h:295</div></div>
</div><!-- fragment --><p>The memory for the CLS object will only be allocated the first time a coroutine calls this function. The optional <a class="el" href="structbio__cls__t.html#a0677d711c8e3ab2eaf4c327e4faba33f">bio_cls_t::init</a> callback will be invoked to initialize this memory block.</p>
<p>Subsequent calls to <code>bio_get_cls</code> from the same coroutine with the same <code>cls</code> pointer will return the same object.</p>
<p>When a coroutine terminates, the optional <a class="el" href="structbio__cls__t.html#a6864ade0718eec5663eecc9a3059bc5e">bio_cls_t::cleanup</a> callback will be invoked. The associated memory will be automatically freed.</p>
<p>Internally, the default logger use CLS to allocate a private format buffer for each coroutine. This avoids the problem of corrupting log content when a coroutine inevitably gets context-switched since logging would involve some sort of I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cls</td><td>The specification for the CLS. Using the same pointer will return the same CLS object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The CLS object </dd></dl>

</div>
</div>
<a id="ga83531922e7e9259e2d0a9bba664bd6da" name="ga83531922e7e9259e2d0a9bba664bd6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83531922e7e9259e2d0a9bba664bd6da">&#9670;&#160;</a></span>bio_get_coro_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * bio_get_coro_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbio__coro__t.html">bio_coro_t</a>&#160;</td>
          <td class="paramname"><em>coro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbio__tag__t.html">bio_tag_t</a> *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the data associated with a coroutine. </p>
<p>This returns the data that was set with <a class="el" href="group__coro.html#ga8b3ca02984a2e1c83528133cb2e5033a">bio_set_coro_data</a>.</p>
<p>If <a class="el" href="group__coro.html#ga8b3ca02984a2e1c83528133cb2e5033a">bio_set_coro_data</a> was never called by the target coroutine, this will return <code>NULL</code>.</p>
<p>If the <code>tag</code> is not the same as what was previously passed to <a class="el" href="group__coro.html#ga8b3ca02984a2e1c83528133cb2e5033a">bio_set_coro_data</a>, this will return <code>NULL</code>.</p>
<p>If the targeted <code>coro</code> has terminated, this will also return <code>NULL</code>.</p>
<p>Typically, the associated data is stack-allocated by the owning coroutine. Since it is safe to call this on a dead coroutine, it is unnecessary and even slightly less efficient to check a coroutine's liveness before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coro</td><td>The coroutine to retrieve data from </td></tr>
    <tr><td class="paramname">tag</td><td>A unique tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated data or NULL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coro.html#ga8b3ca02984a2e1c83528133cb2e5033a" title="Associate the calling coroutine with arbitrary data and a tag.">bio_set_coro_data</a> </dd></dl>

</div>
</div>
<a id="ga5d004977f3fb35d5e5088b951db80645" name="ga5d004977f3fb35d5e5088b951db80645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d004977f3fb35d5e5088b951db80645">&#9670;&#160;</a></span>bio_get_coro_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * bio_get_coro_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbio__coro__t.html">bio_coro_t</a>&#160;</td>
          <td class="paramname"><em>coro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a human-readable name for the coroutine if it has one. </p>
<p>This may return NULL if a name was not given.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coro.html#ga97a7285e28a3af61e336163c931d0adb" title="Give a human-readable name to the calling coroutine.">bio_set_coro_name</a> </dd></dl>

</div>
</div>
<a id="ga8b3ca02984a2e1c83528133cb2e5033a" name="ga8b3ca02984a2e1c83528133cb2e5033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3ca02984a2e1c83528133cb2e5033a">&#9670;&#160;</a></span>bio_set_coro_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bio_set_coro_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbio__tag__t.html">bio_tag_t</a> *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate the calling coroutine with arbitrary data and a tag. </p>
<p>This data can later be retrieved by any coroutine, provided that they pass the same tag to <a class="el" href="group__coro.html#ga83531922e7e9259e2d0a9bba664bd6da">bio_get_coro_data</a>. This allows a coroutine to quickly expose its states to others.</p>
<p>"Module-private" data can be implemented by declaring the tag as a static global variable in a .c/.cpp file. Hence, only functions in the same file can call <a class="el" href="group__coro.html#ga8b3ca02984a2e1c83528133cb2e5033a">bio_set_coro_data</a> and <a class="el" href="group__coro.html#ga83531922e7e9259e2d0a9bba664bd6da">bio_get_coro_data</a>.</p>
<p>This is provided as an additional runtime safety check. Since all <a class="el" href="structbio__coro__t.html" title="Handle to a coroutine.">bio_coro_t</a> handles are interchangable and the user data is just an untyped <code>void*</code> pointer, it is possible to incorrectly pass the wrong coroutine to the wrong function that does not know how to cast the pointer back to the correct concrete type, resulting in undefined behaviour. The tag acts as a type check and access check on the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>An arbitrary pointer </td></tr>
    <tr><td class="paramname">tag</td><td>A unique tag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coro.html#ga83531922e7e9259e2d0a9bba664bd6da" title="Retrieve the data associated with a coroutine.">bio_get_coro_data</a> </dd>
<dd>
<a class="el" href="structbio__tag__t.html" title="A unique tag.">bio_tag_t</a> </dd></dl>

</div>
</div>
<a id="ga97a7285e28a3af61e336163c931d0adb" name="ga97a7285e28a3af61e336163c931d0adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97a7285e28a3af61e336163c931d0adb">&#9670;&#160;</a></span>bio_set_coro_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bio_set_coro_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give a human-readable name to the calling coroutine. </p>
<p>Using the default logger, this name will be displayed instead of the coroutine handle's numeric representation (e.g: <code>main</code> instead of <code>1:0</code>).</p>
<p>It is by design that a coroutine can only name itself, hence the lack of a <code>coro</code> argument in this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__coro.html#ga5d004977f3fb35d5e5088b951db80645" title="Get a human-readable name for the coroutine if it has one.">bio_get_coro_name</a> </dd></dl>

</div>
</div>
<a id="gae947d3e23e02081e761fde6022c9805a" name="gae947d3e23e02081e761fde6022c9805a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae947d3e23e02081e761fde6022c9805a">&#9670;&#160;</a></span>bio_spawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbio__coro__t.html">bio_coro_t</a> bio_spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coro.html#ga329934e366d0c7a3de9becc8bc3c67c5">bio_entrypoint_t</a>&#160;</td>
          <td class="paramname"><em>entrypoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a new coroutine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entrypoint</td><td>The entrypoint for the coroutine. </td></tr>
    <tr><td class="paramname">userdata</td><td>Data to pass to the entrypoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new coroutine handle. </dd></dl>

</div>
</div>
<a id="ga6f37450bb3b8f1293eb53858af4de8a8" name="ga6f37450bb3b8f1293eb53858af4de8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f37450bb3b8f1293eb53858af4de8a8">&#9670;&#160;</a></span>bio_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bio_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Let a different coroutine run. </p>
<p>Since cooperative scheduling is used in the main thread, if a coroutine is doing something intensive, it could block other coroutines from running. Calling this function will let other coroutines run. However, it is probably a better idea to use the <a class="el" href="group__misc.html#ga9e1d740968b4d69a528306ae4ddf995e">async thread pool</a> instead.</p>
<p>Another use for this would be to implement a busy wait. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
